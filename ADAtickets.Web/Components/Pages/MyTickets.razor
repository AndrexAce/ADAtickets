<!-- ADAtickets is a simple, lightweight, open source ticketing system
interacting with your enterprise repositories on Azure DevOps
with a two-way synchronization.
Copyright (C) 2025  Andrea Lucchese

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.-->
@page "/my-tickets"
@layout MainLayout

@using System.Globalization
@using ADAtickets.Client
@using ADAtickets.Shared.Constants
@using ADAtickets.Shared.Dtos.Requests
@using ADAtickets.Shared.Dtos.Responses
@using ADAtickets.Shared.Models
@using ADAtickets.Web.Components.Layout
@using ADAtickets.Web.Components.Shared
@using ADAtickets.Web.Components.Utilities
@using AutoMapper
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.Authorization
@using System.Net
@using System.Security.Claims
@using static ADAtickets.Web.Components.Utilities.Dialogs

@inject IStringLocalizer<MyTickets> loc
@inject TicketsClient ticketsClient
@inject UsersClient usersClient
@inject PlatformsClient platformsClient
@inject IToastService toastService
@inject IDialogService dialogService
@inject IMapper mapper
@inject AuthenticationStateProvider authenticationStateProvider
@inject IConfiguration configuration

@attribute [Authorize(Policy = Policy.Everyone)]

<PageTitle>ADAtickets - @loc["Title"]</PageTitle>
<FluentStack Orientation="Orientation.Vertical">
    <FluentStack Orientation="Orientation.Horizontal" VerticalAlignment="VerticalAlignment.Center" HorizontalAlignment="HorizontalAlignment.End">
        @if (selectedTickets.Count > 0)
        {
            <FluentMenuButton Text="@loc["ActionsButton"]" IconStart="@(new Icons.Regular.Size20.SelectAllOn())">
                <FluentLabel Typo="Typography.H6">@loc["EditStatusMenuLabel"]</FluentLabel>
                <FluentMenuItem Label="@loc["DeleteMenuItem"]" OnClick="HandleDeleteClick">
                    <span slot="start"><FluentIcon Value="@(new Icons.Regular.Size20.DeleteDismiss())" Color="Color.Neutral" Slot="start" /></span>
                </FluentMenuItem>
                <FluentMenuItem Label="@loc["CloseMenuItem"]" OnClick="HandleCloseClick">
                    <span slot="start"><FluentIcon Value="@(new Icons.Regular.Size20.Checkmark())" Color="Color.Neutral" Slot="start" /></span>
                </FluentMenuItem>
                <FluentDivider />
                <FluentLabel Typo="Typography.H6">@loc["AssignMenuLabel"]</FluentLabel>
                <FluentMenuItem Label="@loc["AssignMenuItem"]">
                    <ChildContent>
                        <span slot="start"><FluentIcon Value="@(new Icons.Regular.Size20.Person())" Color="Color.Neutral" Slot="start" /></span>
                    </ChildContent>
                    <MenuItems>
                        @foreach (var user in Users ?? [])
                        {
                            <FluentMenuItem Role="MenuItemRole.MenuItem" Label="@($"{user.Name} {user.Surname}")" OnClick="args => HandleAssignClick(user.Id)"/>
                        }
                    </MenuItems>
                </FluentMenuItem>
            </FluentMenuButton>
        }
        <FluentMenuButton Text="@loc["EditViewButton"]" IconStart="@(new Icons.Regular.Size20.TextAlignLeft())">
            <FluentLabel Typo="Typography.H6">@loc["SortMenuLabel"]</FluentLabel>
            <FluentMenuItem Label="@loc["SortTitleMenuItem"]">
                <ChildContent>
                    <span slot="start"><FluentIcon Value="@(new Icons.Regular.Size20.TextCaseTitle())" Color="Color.Neutral" Slot="start" /></span>
                </ChildContent>
                <MenuItems>
                    <FluentMenuItem Role="MenuItemRole.MenuItem" Label="@loc["SortAscendantMenuItem"]" />
                    <FluentMenuItem Role="MenuItemRole.MenuItem" Label="@loc["SortDescendantMenuItem"]" />
                </MenuItems>
            </FluentMenuItem>
            <FluentMenuItem Label="@loc["SortLastUpdateMenuItem"]">
                <ChildContent>
                    <span slot="start"><FluentIcon Value="@(new Icons.Regular.Size20.Calendar())" Color="Color.Neutral" Slot="start" /></span>
                </ChildContent>
                <MenuItems>
                    <FluentMenuItem Role="MenuItemRole.MenuItem" Label="@loc["SortAscendantMenuItem"]" />
                    <FluentMenuItem Role="MenuItemRole.MenuItem" Label="@loc["SortDescendantMenuItem"]" />
                </MenuItems>
            </FluentMenuItem>
            <FluentMenuItem Label="@loc["SortPriorityMenuItem"]">
                <ChildContent>
                    <span slot="start"><FluentIcon Value="@(new Icons.Regular.Size20.ArrowDownExclamation())" Color="Color.Neutral" Slot="start" /></span>
                </ChildContent>
                <MenuItems>
                    <FluentMenuItem Role="MenuItemRole.MenuItem" Label="@loc["SortAscendantMenuItem"]" />
                    <FluentMenuItem Role="MenuItemRole.MenuItem" Label="@loc["SortDescendantMenuItem"]"/>
                </MenuItems>
            </FluentMenuItem>
            <FluentDivider />
            <FluentLabel Typo="Typography.H6">@loc["FilterMenuLabel"]</FluentLabel>
            <FluentMenuItem Label="@loc["FilterOperatorMenuItem"]">
                <ChildContent>
                    <span slot="start"><FluentIcon Value="@(new Icons.Regular.Size20.Person())" Color="Color.Neutral" Slot="start" /></span>
                </ChildContent>
                <MenuItems>
                    @foreach (var user in Users ?? [])
                    {
                        <FluentMenuItem Role="MenuItemRole.MenuItem" Label="@($"{user.Name} {user.Surname}")" />
                    }
                </MenuItems>
            </FluentMenuItem>
            <FluentMenuItem Label="@loc["SortLastUpdateMenuItem"]">
                <ChildContent>
                    <span slot="start"><FluentIcon Value="@(new Icons.Regular.Size20.Calendar())" Color="Color.Neutral" Slot="start" /></span>
                </ChildContent>
                <MenuItems>
                    <FluentMenuItem Role="MenuItemRole.MenuItem" Label="@loc["FilterLastUpdateHourMenuItem"]" />
                    <FluentMenuItem Role="MenuItemRole.MenuItem" Label="@loc["FilterLastUpdateDayMenuItem"]" />
                    <FluentMenuItem Role="MenuItemRole.MenuItem" Label="@loc["FilterLastUpdateWeekMenuItem"]" />
                    <FluentMenuItem Role="MenuItemRole.MenuItem" Label="@loc["FilterLastUpdateMonthMenuItem"]" />
                    <FluentMenuItem Role="MenuItemRole.MenuItem" Label="@loc["FilterLastUpdateYearMenuItem"]" />
                </MenuItems>
            </FluentMenuItem>
            <FluentMenuItem Label="@loc["FilterCategoryMenuItem"]">
                <ChildContent>
                    <span slot="start"><FluentIcon Value="@(new Icons.Regular.Size20.Tag())" Color="Color.Neutral" Slot="start" /></span>
                </ChildContent>
                <MenuItems>
                    <FluentMenuItem Role="MenuItemRole.MenuItem" Label="@loc["FilterCategoryBugMenuItem"]" />
                    <FluentMenuItem Role="MenuItemRole.MenuItem" Label="@loc["FilterCategoryFeatureMenuItem"]" />
                </MenuItems>
            </FluentMenuItem>
            <FluentMenuItem Label="@loc["FilterPlatformMenuItem"]">
                <ChildContent>
                    <span slot="start"><FluentIcon Value="@(new Icons.Regular.Size20.Apps())" Color="Color.Neutral" Slot="start" /></span>
                </ChildContent>
                <MenuItems>
                    @foreach (var platform in platforms ?? [])
                    {
                        <FluentMenuItem Role="MenuItemRole.MenuItem" Label="@($"{platform.Name}")" />
                    }
                </MenuItems>
            </FluentMenuItem>
            <FluentMenuItem Label="@loc["SortPriorityMenuItem"]">
                <ChildContent>
                    <span slot="start"><FluentIcon Value="@(new Icons.Regular.Size20.ArrowDownExclamation())" Color="Color.Neutral" Slot="start" /></span>
                </ChildContent>
                <MenuItems>
                    <FluentMenuItem Role="MenuItemRole.MenuItem" Label="@loc["FilterPriorityLowMenuItem"]" />
                    <FluentMenuItem Role="MenuItemRole.MenuItem" Label="@loc["FilterPriorityMediumMenuItem"]" />
                    <FluentMenuItem Role="MenuItemRole.MenuItem" Label="@loc["FilterPriorityHighMenuItem"]" />
                </MenuItems>
            </FluentMenuItem>
        </FluentMenuButton>
    </FluentStack>
    <FluentTabs Size="TabSize.Small" Width="100%" OnTabChange="HandleTabChange">
        <FluentTab Label="@loc["AllTab"]" Icon="@(new Icons.Regular.Size20.Grid())" Id="AllTab">
        </FluentTab>
        <FluentTab Label="@loc["UnassignedTab"]" Icon="@(new Icons.Regular.Size20.Question())" Id="UnassignedTab">
        </FluentTab>
        <FluentTab Label="@loc["ToReplyTab"]" Icon="@(new Icons.Regular.Size20.ArrowReply())" Id="ToReplyTab">
        </FluentTab>
        <FluentTab Label="@loc["WaitingTab"]" Icon="@(new Icons.Regular.Size20.HourglassHalf())" Id="WaitingTab">
        </FluentTab>
        <FluentTab Label="@loc["ClosedTab"]" Icon="@(new Icons.Regular.Size20.Checkmark())" Id="ClosedTab">
        </FluentTab>
    </FluentTabs>

    @if (tickets is null)
    {
        <div style="width: 100%; display: flex; align-items: center; padding: 2rem; flex-direction: column;">
            <FluentProgressRing />
        </div>
    }
    else if (!tickets.Any())
    {
        <div style="width: 100%; display: flex; align-items: center; padding: 2rem; flex-direction: column;">
            <FluentIcon Value="@(new Icons.Filled.Size20.Checkmark())" Color="@Color.Accent" />
            <FluentLabel Typo="Typography.H6">@loc["NoTicketsText"]</FluentLabel>
        </div>
    }
    else
    {
        <div class="tickets-grid">
            <CascadingValue Value="@Users">
                @foreach (var ticket in tickets)
                {
                    <TicketCard Ticket="@ticket" SelectedChanged="HandleSelectedChanged" StateChanged="HandleStateChanged"/>
                }
            </CascadingValue>
        </div>
    }
</FluentStack>

@code {
    private IEnumerable<UserResponseDto>? Users { get; set; }

    private IEnumerable<TicketResponseDto>? tickets;
    private IEnumerable<PlatformResponseDto>? platforms;
    private readonly HashSet<Guid> selectedTickets = [];
    private string? currentTab;

    protected override async Task OnInitializedAsync()
    {  
        try
        {
            await LoadUsers();
            await LoadTickets(await GetFilters());
            await LoadPlatforms();
        }
        catch (Exception ex)
        {
            toastService.ShowCommunicationToast(Toasts.ErrorToastParameters(ex, loc["LoadingErrorToastTitle"], loc["LoadingErrorToastDetails"]));
        }
    }

    private async Task LoadUsers()
    {
        var result = await usersClient.GetAllAsync();
        Users = result.Item2;
    }

    private async Task LoadTickets(IEnumerable<KeyValuePair<string, string>> filters)
    {
        var result = await ticketsClient.GetAllAsync(filters);
        tickets = result.Item2;
    }

    private async Task LoadPlatforms()
    {
        var result = await platformsClient.GetAllAsync();
        platforms = result.Item2;
    }

    private async Task<IEnumerable<KeyValuePair<string, string>>> GetFilters()
    {
        var authState = await authenticationStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;

        return GetFilterFromUser(user).Union(GetFilterFromTab(user));
    }

    private IEnumerable<KeyValuePair<string, string>> GetFilterFromUser(ClaimsPrincipal currentUser)
    {
        if (currentUser?.Identity?.IsAuthenticated == true)
        {
            return currentUser.FindFirstValue("tid") == configuration["Entra:TenantId"] ? 
            [] : new Dictionary<string, string> { { nameof(TicketResponseDto.CreatorUserId), currentUser.FindFirstValue("uid") ?? "" } };
        }

        return [];
    }

    private IEnumerable<KeyValuePair<string, string>> GetFilterFromTab(ClaimsPrincipal currentUser)  
    {  
        return currentTab switch  
        {  
            "AllTab" => [],  
            "UnassignedTab" => new Dictionary<string, string> { { nameof(TicketResponseDto.Status), nameof(Status.Unassigned) } },  
            "ToReply" when currentUser.FindFirstValue("tid") == configuration["Entra:TenantId"] => new Dictionary<string, string> { { nameof(TicketResponseDto.Status), nameof(Status.WaitingOperator) } },
            "ToReply" when currentUser.FindFirstValue("tid") != configuration["Entra:TenantId"] => new Dictionary<string, string> { { nameof(TicketResponseDto.Status), nameof(Status.WaitingUser) } },
            "WaitingTab" when currentUser.FindFirstValue("tid") == configuration["Entra:TenantId"] => new Dictionary<string, string> { { nameof(TicketResponseDto.Status), nameof(Status.WaitingUser) } },
            "WaitingTab" when currentUser.FindFirstValue("tid") != configuration["Entra:TenantId"] => new Dictionary<string, string> { { nameof(TicketResponseDto.Status), nameof(Status.WaitingOperator) } },
            "ClosedTab" => new Dictionary<string, string> { { nameof(TicketResponseDto.Status), nameof(Status.Closed) } },  
            _ => []
        };  
    }

    private async Task HandleTabChange(FluentTab fluentTab)
    {
        currentTab = fluentTab?.Id;
        await LoadTickets(await GetFilters());
    }

    private void HandleSelectedChanged(SelectedChangedEventArgs args)
    {
        if (args.IsSelected)
        {
            selectedTickets.Add(args.TicketId);
        }
        else
        {
            selectedTickets.Remove(args.TicketId);
        }
    }

    private async Task HandleDeleteClick()
    {
        await dialogService.ShowDialogAsync<SimpleDialog>(
            new SimpleDialogContent
            {
                Message = loc["DeleteConfirmDialogMessage"],
                ConfirmAction = HandleConfirmDelete,
                ConfirmButtonIcon = new Icons.Regular.Size20.DeleteDismiss(),
            },
            Dialogs.ConfirmDialogParameters(loc["DeleteConfirmDialogTitle"], loc["DeleteConfirmDialogConfirmButton"], loc["DeleteConfirmDialogCancelButton"]));
    }

    private async Task HandleCloseClick()
    {
        await dialogService.ShowDialogAsync<SimpleDialog>(
            new SimpleDialogContent
            {
                Message = loc["CloseConfirmDialogMessage"],
                ConfirmAction = HandleConfirmClose,
                ConfirmButtonIcon = new Icons.Regular.Size20.Checkmark(),
            },
            Dialogs.ConfirmDialogParameters(loc["CloseConfirmDialogTitle"], loc["CloseConfirmDialogConfirmButton"], loc["CloseConfirmDialogCancelButton"]));
    }

    private async Task HandleAssignClick(Guid operatorId)
    {
        await HandleAssign(operatorId);
    }

    private async Task HandleConfirmDelete()
    {
        var progressToastParameters = Toasts.ProgressToastParameters("Delete", loc["DeleteProgressToastTitle"], loc["DeleteProgressToastDetails"]);

        toastService.ShowProgressToast(progressToastParameters);

        try
        {
            foreach (var ticketId in selectedTickets)
            {
                var deleteResponse = await ticketsClient.DeleteAsync(ticketId);

                // If the ticket could not be deleted, send an error.
                if (deleteResponse is HttpStatusCode.NoContent)
                {
                    // Update the progress bar and the toast.
                    progressToastParameters.Content.Progress += 100 / selectedTickets.Count;
                    if (progressToastParameters.Content.Progress > 100) progressToastParameters.Content.Progress = 100;

                    toastService.UpdateToast("Delete", progressToastParameters);
                }
                else throw new HttpRequestException(deleteResponse.ToString(), null, deleteResponse);
            }

            toastService.ShowCommunicationToast(Toasts.ConfirmToastParameters(loc["DeleteSuccessToastTitle"], loc["DeleteSuccessToastDetails"]));
        }
        catch (Exception ex)
        {
            toastService.ShowCommunicationToast(Toasts.ErrorToastParameters(ex, loc["DeleteErrorToastTitle"], loc["DeleteErrorToastDetails"]));
        }
        finally
        {
            toastService.ClearQueueProgressToasts();

            // Deselect all tickets.
            selectedTickets.Clear();

            // Reload the tickets.
            await LoadTickets(await GetFilters());
        }
    }

    private async Task HandleConfirmClose()
    {
        var progressToastParameters = Toasts.ProgressToastParameters("Close", loc["CloseProgressToastTitle"], loc["CloseProgressToastDetails"]);

        toastService.ShowProgressToast(progressToastParameters);

        try
        {
            foreach (var ticketId in selectedTickets)
            {
                var getResponse = await ticketsClient.GetAsync(ticketId);

                // // If the ticket could not be retrieved, send an error.
                if (getResponse is (HttpStatusCode.OK, not null))
                {
                    // Update the ticket status to Closed.
                    getResponse.Item2.Status = Status.Closed;

                    var putResponse = await ticketsClient.PutAsync(ticketId, mapper.Map(getResponse, new TicketRequestDto()));

                    // If the ticket could not be closed, send an error.
                    if (putResponse is (HttpStatusCode.OK, not null))
                    {
                        // Update the progress bar and the toast.
                        progressToastParameters.Content.Progress += 100 / selectedTickets.Count;
                        if (progressToastParameters.Content.Progress > 100) progressToastParameters.Content.Progress = 100;

                        toastService.UpdateToast("Close", progressToastParameters);
                    }
                    else throw new HttpRequestException(putResponse.Item1.ToString(), null, putResponse.Item1);
                }
                else throw new HttpRequestException(getResponse.Item1.ToString(), null, getResponse.Item1);
            }

            toastService.ShowCommunicationToast(Toasts.ConfirmToastParameters(loc["CloseSuccessToastTitle"], loc["CloseSuccessToastDetails"]));
        }
        catch (Exception ex)
        {
            toastService.ShowCommunicationToast(Toasts.ErrorToastParameters(ex, loc["CloseErrorToastTitle"], loc["CloseErrorToastDetails"]));
        }
        finally
        {
            toastService.ClearQueueProgressToasts();

            // Deselect all tickets.
            selectedTickets.Clear();

            // Reload the tickets.
            await LoadTickets(await GetFilters());
        }
    }

    private async Task HandleAssign(Guid operatorId)
    {
        var progressToastParameters = Toasts.ProgressToastParameters("Assign", loc["AssignProgressToastTitle"], loc["AssignProgressToastDetails"]);

        toastService.ShowProgressToast(progressToastParameters);

        try
        {
            foreach (var ticketId in selectedTickets)
            {
                var getResponse = await ticketsClient.GetAsync(ticketId);

                // If the ticket could not be retrieved, send an error.
                if (getResponse is (HttpStatusCode.OK, not null))
                {
                    // Update the ticket assignee.
                    getResponse.Item2.OperatorUserId = operatorId;

                    var putResponse = await ticketsClient.PutAsync(ticketId, mapper.Map(getResponse, new TicketRequestDto()));

                    // If the ticket could not be assigned, send an error.
                    if (putResponse is (HttpStatusCode.OK, not null))
                    {
                        // Update the progress bar and the toast.
                        progressToastParameters.Content.Progress += 100 / selectedTickets.Count;
                        if (progressToastParameters.Content.Progress > 100) progressToastParameters.Content.Progress = 100;

                        toastService.UpdateToast("Assign", progressToastParameters);
                    }
                    else throw new HttpRequestException(putResponse.Item1.ToString(), null, putResponse.Item1);
                }
                else throw new HttpRequestException(getResponse.Item1.ToString(), null, getResponse.Item1);
            }

            toastService.ShowCommunicationToast(Toasts.ConfirmToastParameters(loc["AssignSuccessToastTitle"], loc["AssignSuccessToastDetails"]));
        }
        catch (Exception ex)
        {
            toastService.ShowCommunicationToast(Toasts.ErrorToastParameters(ex, loc["AssignErrorToastTitle"], loc["AssignErrorToastDetails"]));
        }
        finally
        {
            toastService.ClearQueueProgressToasts();

            // Deselect all tickets.
            selectedTickets.Clear();

            // Reload the tickets.
            await LoadTickets(await GetFilters());
        }
    }

    private async Task HandleStateChanged()
    {
        await LoadTickets(await GetFilters());
    }
}