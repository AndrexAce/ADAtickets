<!-- ADAtickets is a simple, lightweight, open source ticketing system
interacting with your enterprise repositories on Azure DevOps
with a two-way synchronization.
Copyright (C) 2025  Andrea Lucchese

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.-->
@page "/users"
@layout MainLayout

@using ADAtickets.Client
@using ADAtickets.Shared.Constants
@using ADAtickets.Shared.Dtos.Requests
@using ADAtickets.Shared.Dtos.Responses
@using ADAtickets.Shared.Extensions
@using ADAtickets.Shared.Models
@using ADAtickets.Web.Components.Layout
@using ADAtickets.Web.Components.Shared
@using ADAtickets.Web.Utilities
@using AutoMapper
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.Authorization
@using static ADAtickets.Web.Utilities.Dialogs

@inject IStringLocalizer<Users> loc
@inject IToastService toastService
@inject IDialogService dialogService
@inject IMapper mapper
@inject AuthenticationStateProvider authenticationStateProvider
@inject UsersClient usersClient

@attribute [Authorize(Policy = Policy.AdminOnly)]

<PageTitle>ADAtickets - @loc["Title"]</PageTitle>
<FluentStack Orientation="Orientation.Vertical">
    <FluentStack Orientation="Orientation.Horizontal" VerticalAlignment="VerticalAlignment.Center" HorizontalAlignment="HorizontalAlignment.End">
        <FluentTabs Size="TabSize.Small" Width="100%" OnTabChange="HandleTabChange">
            <FluentTab Label="@loc["AllTab"]" Icon="@(new Icons.Regular.Size20.Person())" Id="AllTab">
            </FluentTab>
            <FluentTab Label="@loc["ItTab"]" Icon="@(new Icons.Regular.Size20.Desktop())" Id="ItTab">
            </FluentTab>
            <FluentTab Label="@loc["ExternalTab"]" Icon="@(new Icons.Regular.Size20.Door())" Id="ExternalTab">
            </FluentTab>
        </FluentTabs>

        @if (selectedUsers.Any())
        {
            @if (!selectedUsers.Any(u => u.IsBlocked))
            {
                <FluentMenuButton Text="@loc["ActionsButton"]" IconStart="@(new Icons.Regular.Size20.SelectAllOn())">
                    <FluentLabel Typo="Typography.H6">@loc["EditStatusMenuLabel"]</FluentLabel>
                    <FluentMenuItem Label="@loc["BlockAllMenuItem"]" OnClick="HandleBlockAllAsync">
                        <span slot="start">
                            <FluentIcon Value="@(new Icons.Regular.Size20.LockClosed())"
                                        Color="Color.Neutral" Slot="start" />
                        </span>
                    </FluentMenuItem>
                </FluentMenuButton>
            }
            @if (!selectedUsers.Any(u => !u.IsBlocked))
            {
                <FluentMenuButton Text="@loc["ActionsButton"]" IconStart="@(new Icons.Regular.Size20.SelectAllOn())">
                    <FluentLabel Typo="Typography.H6">@loc["EditStatusMenuLabel"]</FluentLabel>
                    <FluentMenuItem Label="@loc["UnblockAllMenuItem"]" OnClick="HandleUnblockAllAsync">
                        <span slot="start">
                            <FluentIcon Value="@(new Icons.Regular.Size20.LockOpen())"
                                        Color="Color.Neutral" Slot="start" />
                        </span>
                    </FluentMenuItem>
                </FluentMenuButton>
            }
        }

        @if (currentSort is not null && currentSortDirection is not null)
        {
            <FluentBadge Appearance="Appearance.Accent" Circular="true" OnDismissClick="HandleSortDismissClick"
                         DismissIcon="@(new Icons.Regular.Size20.Dismiss().WithColor(Color.Fill))">
                @if (currentSortDirection == "asc")
                {
                    <FluentIcon Color="Color.Fill" Value="@(new Icons.Regular.Size20.ArrowSortUp())" />
                }
                else
                {
                    <FluentIcon Color="Color.Fill" Value="@(new Icons.Regular.Size20.ArrowSortDown())" />
                }
                @currentSort
            </FluentBadge>
        }

        <FluentMenuButton Text="@loc["EditViewButton"]" IconStart="@(new Icons.Regular.Size20.TextAlignLeft())">
            <FluentLabel Typo="Typography.H6">@loc["SortMenuLabel"]</FluentLabel>
            <FluentMenuItem Label="@loc["SortNameMenuItem"]">
                <ChildContent>
                    <span slot="start"><FluentIcon Value="@(new Icons.Regular.Size20.TextCaseTitle())"
                                                   Color="Color.Neutral" Slot="start"/></span>
                </ChildContent>
                <MenuItems>
                    <FluentMenuItem Role="MenuItemRole.MenuItem" Label="@loc["SortAscendantMenuItem"]"
                                    OnClick='args => HandleSortNameClick("asc")'/>
                    <FluentMenuItem Role="MenuItemRole.MenuItem" Label="@loc["SortDescendantMenuItem"]"
                                    OnClick='args => HandleSortNameClick("desc")'/>
                </MenuItems>
            </FluentMenuItem>
        </FluentMenuButton>
    </FluentStack>

    @if (users is null)
    {
        <div style="width: 100%; display: flex; align-items: center; padding: 2rem; flex-direction: column;">
            <FluentProgressRing />
        </div>
    }
    else
    {
        <FluentGrid AdaptiveRendering="true" Justify="JustifyContent.FlexStart" Spacing="3" Style="width: 100%;">
            <CascadingValue Value="CurrentUserId">
                @foreach (var user in users)
                {
                    <FluentGridItem xs="12" sm="12" md="6" lg="4" Style="display: flex; flex-direction: column; align-items: center;" @key="user.Id">
                        <UserCard User="user" OnSelectedChanged="HandleSelectedChanged" OnBlock="HandleBlockUnblockAsync" OnUnblock="HandleBlockUnblockAsync" />
                    </FluentGridItem>
                }
            </CascadingValue>
        </FluentGrid>
    }
</FluentStack>

@code {

    #region Fields

    // Datasets
    private IEnumerable<UserResponseDto>? users;
    private IEnumerable<UserResponseDto>? originalUsers;

    // State management
    public Guid? CurrentUserId { get; set; }

    private readonly List<UserResponseDto> selectedUsers = [];

    private string? currentTab;
    private string? currentSort;
    private string? currentSortDirection;

    #endregion

    #region Loading data

    protected override async Task OnInitializedAsync()
    {
        await LoadUsersAsync();
    }

    private async Task LoadUsersAsync()
    {
        try
        {
            originalUsers = (await usersClient.GetAllAsync()).Items;
            users = originalUsers;

            var currentUserEmail = await GetCurrentUserEmail();
            CurrentUserId = users.First(u => u.Email == currentUserEmail).Id;

            // After the users are retrieved, sort and filter based on the user preferences.
            ApplySelectedFiltersAndSort();
        }
        catch (Exception ex)
        {
            toastService.ShowCommunicationToast(Toasts.ErrorToastParameters(ex, loc["LoadingErrorToastTitle"], loc["LoadingErrorToastDetails"]));
        }
    }

    #endregion

    #region Event handlers

    private void HandleSortDismissClick()
    {
        currentSort = null;
        currentSortDirection = null;
        ApplySelectedFiltersAndSort();
    }

    private void HandleTabChange(FluentTab fluentTab)
    {
        try
        {
            currentTab = fluentTab?.Id;
            ApplySelectedFiltersAndSort();
        }
        catch (Exception ex)
        {
            toastService.ShowCommunicationToast(Toasts.ErrorToastParameters(ex, loc["LoadingErrorToastTitle"], loc["LoadingErrorToastDetails"]));
        }
    }

    private void HandleSelectedChanged(SelectedChangedEventArgs<UserResponseDto> args)
    {
        if (args.IsSelected)
        {
            selectedUsers.Add(args.Item);
        }
        else
        {
            selectedUsers.RemoveAll(u => u.Id == args.Item.Id);
        }
    }

    private async Task HandleBlockUnblockAsync()
    {
        // Deselect all users.
        selectedUsers.Clear();

        // Reload the users
        await LoadUsersAsync();
    }

    private async Task HandleBlockAllAsync()
    {
        await dialogService.ShowDialogAsync<SimpleDialog>(
            new SimpleDialogContent
            {
                Message = loc["BlockAllConfirmDialogMessage"],
                ConfirmAction = HandleConfirmBlockAllAsync,
                ConfirmButtonIcon = new Icons.Regular.Size20.LockClosed()
            },
            ConfirmDialogParameters(loc["BlockAllConfirmDialogTitle"], loc["BlockAllConfirmDialogConfirmButton"], loc["BlockAllConfirmDialogCancelButton"]));
    }

    private async Task HandleUnblockAllAsync()
    {
        await dialogService.ShowDialogAsync<SimpleDialog>(
            new SimpleDialogContent
            {
                Message = loc["UnblockAllConfirmDialogMessage"],
                ConfirmAction = HandleConfirmUnblockAllAsync,
                ConfirmButtonIcon = new Icons.Regular.Size20.LockOpen()
            },
            ConfirmDialogParameters(loc["UnblockAllConfirmDialogTitle"], loc["UnblockAllConfirmDialogConfirmButton"], loc["UnblockAllConfirmDialogCancelButton"]));
    }

    private async Task HandleConfirmBlockAllAsync()
    {
        var progressToastParameters = Toasts.ProgressToastParameters("Block", loc["BlockAllProgressToastTitle"], loc["BlockAllProgressToastDetails"]);

        toastService.ShowProgressToast(progressToastParameters);

        try
        {
            foreach (var user in selectedUsers)
            {
                await usersClient.PutAsync(user.Id, mapper.Map<UserRequestDto>(user with { IsBlocked = true }));

                // Update the progress bar and the toast.
                progressToastParameters.Content.Progress += 100 / selectedUsers.Count;
                if (progressToastParameters.Content.Progress > 100) progressToastParameters.Content.Progress = 100;

                toastService.UpdateToast("Block", progressToastParameters);
            }

            toastService.ShowCommunicationToast(Toasts.ConfirmToastParameters(loc["BlockAllSuccessToastTitle"], loc["BlockAllSuccessToastDetails"]));
        }
        catch (Exception ex)
        {
            toastService.ShowCommunicationToast(Toasts.ErrorToastParameters(ex, loc["BlockAllErrorToastTitle"], loc["BlockAllErrorToastDetails"]));
        }
        finally
        {
            toastService.ClearProgressToasts();

            // Deselect all users.
            selectedUsers.Clear();

            // Reload the users
            await LoadUsersAsync();
        }
    }

    private async Task HandleConfirmUnblockAllAsync()
    {
        var progressToastParameters = Toasts.ProgressToastParameters("Unblock", loc["UnblockAllProgressToastTitle"], loc["UnblockAllProgressToastDetails"]);

        toastService.ShowProgressToast(progressToastParameters);

        try
        {
            foreach (var user in selectedUsers)
            {
                await usersClient.PutAsync(user.Id, mapper.Map<UserRequestDto>(user with { IsBlocked = false }));

                // Update the progress bar and the toast.
                progressToastParameters.Content.Progress += 100 / selectedUsers.Count;
                if (progressToastParameters.Content.Progress > 100) progressToastParameters.Content.Progress = 100;

                toastService.UpdateToast("Unblock", progressToastParameters);
            }

            toastService.ShowCommunicationToast(Toasts.ConfirmToastParameters(loc["UnblockAllSuccessToastTitle"], loc["UnblockAllSuccessToastDetails"]));
        }
        catch (Exception ex)
        {
            toastService.ShowCommunicationToast(Toasts.ErrorToastParameters(ex, loc["UnblockAllErrorToastTitle"], loc["UnblockAllErrorToastDetails"]));
        }
        finally
        {
            toastService.ClearProgressToasts();

            // Deselect all users.
            selectedUsers.Clear();

            // Reload the users
            await LoadUsersAsync();
        }
    }

    private void HandleSortNameClick(string order)
    {
        currentSort = loc["SortNameMenuItem"];
        currentSortDirection = order;
        ApplySelectedFiltersAndSort();
    }

    private void ApplySelectedFiltersAndSort()
    {
        var filteredUsers = ApplyFilter(originalUsers);

        users = ApplySort(filteredUsers);
    }

    private IEnumerable<UserResponseDto>? ApplyFilter(IEnumerable<UserResponseDto>? users)
    {
        return currentTab switch
        {
            "AllTab" => users,
            "ItTab" => users?.Where(u => u.Type == UserType.Operator || u.Type == UserType.Admin),
            "ExternalTab" => users?.Where(u => u.Type == UserType.User),
            _ => users
        };
    }

    private IEnumerable<UserResponseDto>? ApplySort(IEnumerable<UserResponseDto>? users)
    {
        // Apply only the current sort
        if (currentSort == loc["SortNameMenuItem"])
        {
            return currentSortDirection == "asc" ? users?.OrderBy(t => t.Name) : users?.OrderByDescending(t => t.Name);
        }

        return users;
    }

    private async Task<string> GetCurrentUserEmail()
    {
        var authState = await authenticationStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;

        return user.GetEmail()!;
    }

    #endregion
}
