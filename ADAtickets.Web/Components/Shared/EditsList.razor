<!-- ADAtickets is a simple, lightweight, open source ticketing system
interacting with your enterprise repositories on Azure DevOps
with a two-way synchronization.
Copyright (C) 2025  Andrea Lucchese

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.-->
@inherits ComponentBase
@implements IAsyncDisposable

@using ADAtickets.Client
@using ADAtickets.Shared.Dtos.Responses
@using ADAtickets.Shared.Models
@using ADAtickets.Web.Utilities
@using Humanizer

@inject IStringLocalizer<EditsList> loc
@inject IConfiguration configuration
@inject IToastService toastService
@inject SignalRService signalRService
@inject EditsClient editsClient

<FluentStack Orientation="Orientation.Vertical" Style="height: 90%; overflow-y: auto;">
    @if (edits is null)
    {
        <div style="width: 100%; display: flex; align-items: center; padding: 2rem; flex-direction: column;">
            <FluentProgressRing />
        </div>
    }
    else
    {
        @foreach (var edit in edits)
        {
            <FluentStack Orientation="Orientation.Horizontal" VerticalAlignment="VerticalAlignment.Center" Style="padding-right: 0.5rem;">
                <FluentPersona ImageSize="2rem" Initials="@GetInitials(edit.SenderName)" />
                <FluentStack Orientation="Orientation.Vertical" VerticalGap="0">
                    <span style="max-width: 111px; text-wrap: wrap;"><b>@edit.SenderName</b></span>
                    <span>@(edit.EditDateTime.ToLocalTime().Humanize())</span>
                    <span>@loc[edit.Description]</span>
                </FluentStack>
                @if (edit.OldStatus == edit.NewStatus)
                {
                    @GetStatusBadge(edit.OldStatus)
                }
                else
                {
                    @GetStatusBadge(edit.OldStatus)
                    <FluentIcon Color="Color.FillInverse" Value="@(new Icons.Regular.Size20.ArrowRight())" />
                    @GetStatusBadge(edit.NewStatus)
                }
            </FluentStack>
        }
    }
</FluentStack>

@code {
    [Parameter]
    public Guid TicketId { get; set; }

    private IEnumerable<EditResponseDto>? edits;

    override protected async Task OnInitializedAsync()
    {
        // Subscribe to refresh events
        await SetupSignalRAsync();

        // Load the edits list
        await LoadEditsAsync();
    }

    private async Task SetupSignalRAsync()
    {
        // Register handlers for API-triggered methods
        Action handlersRegistration = () =>
        {
            signalRService.On("EditCreated", HandleRefreshRequestedAsync);
            signalRService.On("EditDeleted", HandleRefreshRequestedAsync);
        };

        // Connect to the hub
        await signalRService.StartAsync($"{configuration["ADAticketsAPI:BaseUrl"]}/editsHub", handlersRegistration);
        // Join the personal group for notifications
        await signalRService.SendAsync("JoinPersonalGroup", TicketId);
    }

    private async Task LoadEditsAsync()
    {
        try
        {
            var fetchedEdits = (await editsClient.GetAllAsync(
                new Dictionary<string, string> { { nameof(EditResponseDto.TicketId), TicketId.ToString() } }
            )).Items;

            edits = fetchedEdits.OrderByDescending(e => e.EditDateTime);
        }
        catch (Exception ex)
        {
            toastService.ShowCommunicationToast(Toasts.ErrorToastParameters(ex, loc["LoadingErrorToastTitle"], loc["LoadingErrorToastDetails"]));
        }
    }

    private async Task HandleRefreshRequestedAsync()
    {
        await LoadEditsAsync();

        await InvokeAsync(StateHasChanged);
    }

    private RenderFragment GetStatusBadge(Status status) => @<FluentBadge Fill="highlight"
                                                                                  BackgroundColor="@GetStatusAppearance(status)"
                                                                                  Circular="true">
    @GetStatusText(status)
    </FluentBadge>;

    private static string GetStatusAppearance(Status status) => status switch
    {
        Status.Unassigned => "var(--info)",
        Status.WaitingUser => "var(--warning)",
        Status.WaitingOperator => "var(--error)",
        Status.Closed => "var(--success)",
        _ => ""
    };

    private string GetStatusText(Status status) => status switch
    {
        Status.Unassigned => loc["StatusUnassigned"],
        Status.WaitingUser => loc["StatusWaitingUser"],
        Status.WaitingOperator => loc["StatusWaitingOperator"],
        Status.Closed => loc["StatusClosed"],
        _ => ""
    };

    private static string GetInitials(string? fullName)
    {
        if (string.IsNullOrWhiteSpace(fullName))
        {
            return string.Empty;
        }

        return fullName.Split(' ')
            .Where(part => !string.IsNullOrWhiteSpace(part))
            .Select(part => part[0])
            .Aggregate(string.Empty, (acc, initial) => acc + initial);
    }

    public async ValueTask DisposeAsync()
    {
        await signalRService.StopAsync();
    }
}
