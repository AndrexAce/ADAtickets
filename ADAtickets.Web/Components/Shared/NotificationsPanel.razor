<!-- ADAtickets is a simple, lightweight, open source ticketing system
interacting with your enterprise repositories on Azure DevOps
with a two-way synchronization.
Copyright (C) 2025  Andrea Lucchese

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.-->
@implements IDialogContentComponent
@implements IDisposable
@using System.Security.Claims
@using ADAtickets.Client
@using ADAtickets.Shared.Dtos.Responses
@using ADAtickets.Web.Utilities
@using Microsoft.FluentUI.AspNetCore.Components.Icons.Regular
@using static ADAtickets.Web.Utilities.Dialogs

@inject IStringLocalizer<NotificationsPanel> loc
@inject NavigationManager navigationManager
@inject NotificationsManager notificationsManager
@inject UserNotificationsClient userNotificationsClient

<FluentDialogHeader ShowDismiss="false" ShowDismissTooltip="false">
    <FluentStack Orientation="Orientation.Vertical" HorizontalAlignment="HorizontalAlignment.Left">
        <FluentStack Orientation="Orientation.Horizontal" HorizontalAlignment="HorizontalAlignment.Right">
            @if (selectedUserNotifications.Any())
            {
                <FluentButton Appearance="Appearance.Lightweight" IconStart="@(new Size20.CommentMultipleCheckmark())" OnClick="MarkSelectedAsReadAsync">@loc["MarkAsReadButton"]</FluentButton>
            }
            <FluentButton Appearance="Appearance.Lightweight" IconStart="@(new Size20.Dismiss())"
                          OnClick="HandleCancelClickAsync" />
        </FluentStack>
        <FluentLabel Typo="Typography.PaneHeader">@loc["NotificationsPanelTitle"]</FluentLabel>
    </FluentStack>
</FluentDialogHeader>

<FluentDialogBody>
    @if (userNotifications is null)
    {
        <div style="width: 100%; display: flex; align-items: center; padding: 2rem; flex-direction: column;">
            <FluentProgressRing/>
        </div>
    }
    else if (!userNotifications.Any())
    {
        <div style="width: 100%; display: flex; align-items: center; padding: 2rem; flex-direction: column;">
            <FluentIcon Value="@(new Icons.Filled.Size20.Checkmark())" Color="@Color.Accent" />
            <FluentLabel Typo="Typography.H6">@loc["NoNotificationsText"]</FluentLabel>
        </div>
    }
    else
    {
        <FluentStack Orientation="Orientation.Vertical" HorizontalAlignment="HorizontalAlignment.Center" VerticalAlignment="VerticalAlignment.Center">
            @foreach (var userNotification in userNotifications)
            {
                <NotificationCard UserNotification="userNotification" SelectedChanged="HandleSelectedChanged"
                                  OnRead="HandleReadAsync" OnDelete="HandleDeleteAsync" OnOpen="HandleOpenAsync" @key="userNotification.Id" />
            }
        </FluentStack>
    }
</FluentDialogBody>

<FluentDialogFooter Visible="false" />

@code {

    /// <summary>
    ///     The dialog object bound to this component.
    /// </summary>
    [CascadingParameter]
    public FluentDialog Dialog { get; set; } = default!;

    private IEnumerable<UserNotificationResponseDto>? userNotifications;
    private readonly HashSet<UserNotificationResponseDto> selectedUserNotifications = [];

    protected override void OnInitialized()
    {
        notificationsManager.OnUserNotificationsChanged += HandleUserNotificationsChanged;

        userNotifications = notificationsManager.UserNotifications;
    }

    private void HandleUserNotificationsChanged()
    {
        userNotifications = notificationsManager.UserNotifications;

        InvokeAsync(StateHasChanged);
    }

    private async Task HandleCancelClickAsync()
    {
        await Dialog.CancelAsync();
    }

    private void HandleSelectedChanged(SelectedChangedEventArgs<UserNotificationResponseDto> args)
    {
        if (args.IsSelected)
        {
            selectedUserNotifications.Add(args.Item);
        }
        else
        {
            selectedUserNotifications.Remove(args.Item);
        }
    }

    private async Task HandleReadAsync(UserNotificationResponseDto notification)
    {
        await notificationsManager.MarkAsReadAsync(notification.Id, userNotificationsClient);
    }

    private async Task HandleDeleteAsync(UserNotificationResponseDto notification)
    {
        await notificationsManager.DeleteAsync(notification.Id, userNotificationsClient);
    }

    private async Task HandleOpenAsync(UserNotificationResponseDto notification)
    {
        // Mark the notification as read before navigating
        await notificationsManager.MarkAsReadAsync(notification.Id, userNotificationsClient);
        
        navigationManager.NavigateTo($"/ticket/{notification.TicketId}", true);
    }

    private async Task MarkSelectedAsReadAsync()
    {
        foreach (var selectedUserNotification in selectedUserNotifications)
        {
            await notificationsManager.MarkAsReadAsync(selectedUserNotification.Id, userNotificationsClient);
        }

        selectedUserNotifications.Clear();
    }

    public void Dispose()
    {
        notificationsManager.OnUserNotificationsChanged -= HandleUserNotificationsChanged;
    }
}